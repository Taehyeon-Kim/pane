# Story 1.3: Skill Manifest Data Structures & Parser

## Status
Done

## Story
**As a** developer,
**I want** skill manifest format defined with parsing and validation,
**so that** skills can be discovered and loaded from YAML files.

## Acceptance Criteria
1. `SkillManifest` struct is defined with all required fields (id, name, description, exec, ui.mode)
2. Optional fields are supported (version, args, tags, estimated_time, ui.fullscreen, context.*)
3. YAML parser can load valid `pane-skill.yaml` files into SkillManifest struct
4. Invalid manifests are rejected with clear error messages
5. Validation ensures required fields are present
6. Unit tests exist for manifest parsing (valid and invalid cases)

## Tasks / Subtasks

- [x] Define data structures for skill manifests (AC: 1, 2)
  - [x] Create `src/skills/` directory and `src/skills/mod.rs`
  - [x] Create `src/skills/manifest.rs` module
  - [x] Define `UiMode` enum (Tui, Inline)
  - [x] Define `UiConfig` struct with mode and fullscreen fields
  - [x] Define `ContextConfig` struct with pass_cwd, pass_git_root, pass_project_name, pass_stdin_json fields
  - [x] Define `SkillManifest` struct with all required and optional fields per data-models.md
  - [x] Derive Debug, Clone, PartialEq traits
  - [x] Use serde derive macros for serialization/deserialization
  - [x] Add doc comments to all public types and fields

- [x] Implement YAML parsing (AC: 3)
  - [x] Add serde_yaml dependency to Cargo.toml
  - [x] Implement `SkillManifest::from_yaml_str()` function returning anyhow::Result<SkillManifest>
  - [x] Implement `SkillManifest::from_yaml_file()` function taking PathBuf, returning anyhow::Result<SkillManifest>
  - [x] Add context to errors using .context() for helpful messages
  - [x] Never use unwrap() or expect() - use ? operator

- [x] Implement validation (AC: 4, 5)
  - [x] Add `validate()` method to SkillManifest
  - [x] Validate required fields: id, name, description, exec are non-empty
  - [x] Validate id format: lowercase alphanumeric + hyphens only (regex: `^[a-z0-9-]+$`)
  - [x] Validate exec is non-empty string
  - [x] Return validation errors with context about which field failed
  - [x] Call validate() automatically in from_yaml_* functions

- [x] Write unit tests for manifest parsing (AC: 6, Testing requirement)
  - [x] Create test fixtures in tests/fixtures/skills/ directory
  - [x] Test valid minimal manifest (required fields only)
  - [x] Test valid full manifest (all optional fields)
  - [x] Test invalid YAML produces helpful error
  - [x] Test missing required field (id, name, description, exec)
  - [x] Test invalid id format (uppercase, spaces, special chars)
  - [x] Test validation catches empty required fields
  - [x] Test from_yaml_file() loads manifest correctly
  - [x] Follow AAA pattern (Arrange, Act, Assert)
  - [x] Use rstest for parametric tests where appropriate

- [x] Integration with project (Module declaration)
  - [x] Add `mod skills;` declaration to src/main.rs or src/lib.rs
  - [x] Export SkillManifest publicly from skills module
  - [x] Run cargo build and cargo test to verify compilation
  - [x] Run cargo clippy and cargo fmt to ensure code quality

## Dev Notes

### Previous Story Insights
From Story 1.2 (Configuration System Foundation):
- serde 1.0 already added to Cargo.toml with derive feature enabled
- anyhow 1.0 available for error handling
- tracing 0.1 available for logging
- Project follows strict coding standards: no unwrap/expect, doc comments required, ? operator for errors
- Test fixtures pattern established in tests/fixtures/
- tempfile 3.8 available for integration tests
- All code must pass clippy with -D warnings and rustfmt
[Source: docs/stories/1.2.story.md#Dev Agent Record]

### Tech Stack & Dependencies

**Required Dependencies (add to Cargo.toml):**
- `serde_yaml` 0.9.0 - YAML parsing for skill manifests [Source: architecture/tech-stack.md#technology-stack-table]

**Already Available:**
- `serde` 1.0 - Serialization/deserialization with derive feature (from Story 1.2)
- `anyhow` 1.0 - Error handling (from Story 1.1)
- `tracing` 0.1 - Structured logging [Source: architecture/tech-stack.md#technology-stack-table]

### Data Models

**SkillManifest Structure:**
Based on architecture/data-models.md, the following data structures must be defined:

```rust
/// UI interaction mode for skills
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum UiMode {
    /// Skill takes over terminal with its own TUI
    Tui,
    /// Skill prints to stdout, results embedded in launcher
    Inline,
}

/// UI configuration for skill display
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UiConfig {
    /// How the skill interacts with the terminal
    pub mode: UiMode,
    /// Whether skill uses fullscreen mode (default: true)
    #[serde(default = "default_fullscreen")]
    pub fullscreen: bool,
}

fn default_fullscreen() -> bool {
    true
}

/// Configuration for which context fields to pass to a skill
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(default)]
pub struct ContextConfig {
    /// Whether to pass current working directory
    pub pass_cwd: bool,
    /// Whether to detect and pass git root
    pub pass_git_root: bool,
    /// Whether to pass project name
    pub pass_project_name: bool,
    /// Whether to send full context as JSON to stdin
    pub pass_stdin_json: bool,
}

impl Default for ContextConfig {
    fn default() -> Self {
        Self {
            pass_cwd: true,
            pass_git_root: true,
            pass_project_name: true,
            pass_stdin_json: false,
        }
    }
}

/// Skill manifest representation from pane-skill.yaml
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SkillManifest {
    /// Unique identifier (lowercase alphanumeric + hyphens)
    pub id: String,
    /// Human-readable display name
    pub name: String,
    /// One or two sentence explanation
    pub description: String,
    /// Semantic version of the skill
    #[serde(default = "default_version")]
    pub version: String,
    /// Executable or script name/path to run
    pub exec: String,
    /// Command-line arguments to pass to executable
    #[serde(default)]
    pub args: Vec<String>,
    /// Searchable tags for filtering
    #[serde(default)]
    pub tags: Vec<String>,
    /// Human-readable time estimate (e.g., "1–3 min")
    pub estimated_time: Option<String>,
    /// UI configuration
    pub ui: UiConfig,
    /// Context configuration
    #[serde(default)]
    pub context: ContextConfig,
}

fn default_version() -> String {
    "0.1.0".to_string()
}
```

**Note:** The full `Skill` struct (with source, manifest_path fields) will be defined in future stories. This story only focuses on the manifest parsing.
[Source: architecture/data-models.md#skill]

### File Locations & Structure

**New Files to Create:**
- `src/skills/` - Directory for skill-related modules
- `src/skills/mod.rs` - Module exports for skills
- `src/skills/manifest.rs` - SkillManifest and related types [Source: architecture/source-tree.md]

**Module Integration:**
- Add `mod skills;` declaration to `src/main.rs`
- Export types from skills module: `pub use skills::manifest::{SkillManifest, UiMode, UiConfig, ContextConfig};`

**Test Fixtures Location:**
- `tests/fixtures/skills/` - Valid and invalid manifest YAML files [Source: architecture/test-strategy-and-standards.md#test-data-management]

### Coding Standards & Best Practices

**Critical Rules:**
1. **Never use `unwrap()` or `expect()`** - Use `?` operator or explicit error handling [Source: architecture/coding-standards.md#critical-rules]
2. **All public functions must have doc comments** - Use `///` format with purpose, parameters, returns, errors [Source: architecture/coding-standards.md#critical-rules]
3. **Use `anyhow::Result<T>` for all fallible functions** - Consistent error handling [Source: architecture/coding-standards.md#critical-rules]
4. **Never log sensitive information** - No file contents, env vars (except PANE_*), or full user paths [Source: architecture/coding-standards.md#critical-rules]

**Rust Idioms:**
- Use `#[derive]` macros for common traits (Debug, Clone, PartialEq) [Source: architecture/coding-standards.md#language-specific-guidelines]
- Prefer `impl Trait` over generic type parameters for return types when possible [Source: architecture/coding-standards.md#language-specific-guidelines]
- Use `const` for compile-time constants, not `static` [Source: architecture/coding-standards.md#language-specific-guidelines]

**Import Organization:**
Imports must be grouped in this order:
1. Standard library imports
2. External crate imports
3. Internal crate module imports
[Source: architecture/coding-standards.md#core-standards]

**Serde Attributes:**
- Use `#[serde(rename_all = "lowercase")]` for enums to match YAML convention
- Use `#[serde(default)]` for optional fields with defaults
- Use `#[serde(default = "function_name")]` for custom default values

### Error Handling Strategy

**Manifest Parsing Errors:**
- **Scenario:** Invalid YAML, missing required fields, validation failures
- **Retry Policy:** No retry - return error immediately
- **User-Facing Error:** "Failed to load skill manifest: {specific error with context}"
- **Technical Details:** Use anyhow::Context to add rich error context
[Source: architecture/error-handling-strategy.md#skill-discovery-and-loading-errors]

**Error Context Requirements:**
- Add `.context()` or `.with_context()` for rich error messages
- Include filename in error messages for file loading
- Specify which field failed validation in validation errors
- Use `?` operator for automatic error propagation
[Source: architecture/error-handling-strategy.md#error-propagation]

**Validation Errors:**
- Return specific errors for each validation failure
- Include the actual value that failed validation in error message
- Example: "Invalid skill id 'MySkill': must be lowercase alphanumeric with hyphens only"

### Testing

#### Testing Framework & Organization
**Framework:** `cargo test` + `rstest` 0.18.0 for parametric tests [Source: architecture/test-strategy-and-standards.md#unit-tests]

**Test Location:** Co-located with source files using `#[cfg(test)] mod tests { ... }` [Source: architecture/test-strategy-and-standards.md#unit-tests]

**Coverage Requirement:** ≥80% for core modules (manifest.rs is a core module) [Source: architecture/test-strategy-and-standards.md#unit-tests]

**Test Fixtures Location:** `tests/fixtures/skills/` for sample YAML files [Source: architecture/test-strategy-and-standards.md#test-data-management]

#### Required Test Cases

1. **Valid Minimal Manifest Test**
   - Test YAML with only required fields (id, name, description, exec, ui.mode)
   - Verify defaults are applied (version="0.1.0", fullscreen=true, empty args/tags)

2. **Valid Full Manifest Test**
   - Test YAML with all optional fields populated
   - Verify all fields are correctly deserialized

3. **Invalid YAML Syntax Test**
   - Load malformed YAML from fixtures
   - Verify error message is helpful and context-rich

4. **Missing Required Field Tests** (parametric with rstest)
   - Test missing each required field: id, name, description, exec
   - Verify serde produces clear error about missing field

5. **Invalid ID Format Tests** (parametric with rstest)
   - Test invalid id values: "MySkill" (uppercase), "my skill" (space), "my_skill" (underscore)
   - Verify validation catches format violations with helpful message

6. **Empty Required Field Test**
   - Test manifest with empty string for required fields
   - Verify validation catches empty values

7. **File Loading Test**
   - Test from_yaml_file() loads fixture correctly
   - Test from_yaml_file() with non-existent file produces error

8. **Default Values Test**
   - Test that ContextConfig defaults are applied correctly
   - Test that UiConfig fullscreen defaults to true

**Test Naming Convention:**
- Format: `test_<function>_<scenario>_<expected_outcome>`
- Example: `test_from_yaml_str_valid_minimal_manifest_succeeds`
[Source: architecture/coding-standards.md#test-organization]

**Test Pattern:**
Follow AAA pattern (Arrange, Act, Assert) in all tests
[Source: architecture/test-strategy-and-standards.md#unit-tests]

#### Example Test Structure
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_yaml_str_valid_minimal_manifest_succeeds() {
        // Arrange
        let yaml = r#"
id: test-skill
name: Test Skill
description: A test skill
exec: ./test.sh
ui:
  mode: tui
"#;

        // Act
        let result = SkillManifest::from_yaml_str(yaml);

        // Assert
        assert!(result.is_ok());
        let manifest = result.unwrap();
        assert_eq!(manifest.id, "test-skill");
        assert_eq!(manifest.name, "Test Skill");
        assert_eq!(manifest.version, "0.1.0"); // default
        assert_eq!(manifest.ui.fullscreen, true); // default
    }

    #[rstest]
    #[case("MySkill", "must be lowercase")]
    #[case("my skill", "alphanumeric with hyphens only")]
    #[case("my_skill", "alphanumeric with hyphens only")]
    fn test_validate_invalid_id_format_fails(#[case] invalid_id: &str, #[case] expected_msg: &str) {
        // Arrange
        let mut manifest = create_valid_manifest();
        manifest.id = invalid_id.to_string();

        // Act
        let result = manifest.validate();

        // Assert
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert!(error.to_string().contains(expected_msg));
    }
}
```
[Source: architecture/test-strategy-and-standards.md#unit-tests]

### Example Manifest YAML

**Minimal valid manifest** (tests/fixtures/skills/minimal-valid.yaml):
```yaml
id: claude-tips
name: Claude Code Tips
description: Browse and search Claude Code tips and tricks
exec: ./claude-tips
ui:
  mode: tui
```

**Full valid manifest** (tests/fixtures/skills/full-valid.yaml):
```yaml
id: my-skill
name: My Awesome Skill
description: This is a comprehensive example skill manifest
version: 1.2.3
exec: /usr/local/bin/my-skill
args:
  - --verbose
  - --color
tags:
  - productivity
  - development
  - automation
estimated_time: 2-5 min
ui:
  mode: tui
  fullscreen: true
context:
  pass_cwd: true
  pass_git_root: true
  pass_project_name: true
  pass_stdin_json: false
```

### Performance Constraints
- Manifest parsing must complete in <5ms per file
- No blocking I/O during parsing (file reads are acceptable)
- Validation should be lightweight (simple string checks)
[Source: architecture/tech-stack.md#technology-stack-table - derived from <100ms startup target]

### Project Structure Notes
No structural conflicts detected. This story creates the `src/skills/` module as specified in the architecture source tree. The skills module will be the foundation for skill discovery (Story 1.4) and execution (future stories).

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-18 | 1.0 | Initial story creation | Scrum Master (Bob) |
| 2025-11-18 | 1.1 | Implementation complete | Developer (James) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - implementation completed without issues requiring debug logging.

### Completion Notes List
- All data structures defined with proper serde attributes and doc comments
- YAML parsing implemented with rich error context using anyhow
- Validation includes id format checking with regex (lowercase alphanumeric + hyphens)
- Comprehensive test suite with 14 tests covering all acceptance criteria
- Used rstest for parametric testing of invalid id formats
- Test fixtures created for valid/invalid manifest examples
- All tests pass, clippy clean, rustfmt applied
- Added `#[allow(dead_code)]` annotations for future story usage

### File List
**New Files:**
- src/skills/mod.rs
- src/skills/manifest.rs
- tests/fixtures/skills/minimal-valid.yaml
- tests/fixtures/skills/full-valid.yaml
- tests/fixtures/skills/invalid.yaml

**Modified Files:**
- Cargo.toml (added serde_yaml, regex, rstest dependencies)
- src/main.rs (added skills module declaration)

## QA Results

### Review Date: 2025-11-18

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: Exemplary**

This implementation demonstrates excellent software engineering practices. The code is well-structured, thoroughly tested, and adheres perfectly to all project coding standards. The developer has shown strong attention to detail in error handling, documentation, and test coverage.

**Strengths:**
- Clean architecture with proper module organization (src/skills/mod.rs, src/skills/manifest.rs)
- Comprehensive documentation with detailed doc comments on all public types and methods
- Excellent error handling using anyhow::Result with rich context
- Strong test coverage (14 tests) covering all scenarios including edge cases
- Effective use of serde derives and attributes for YAML parsing
- Parametric testing with rstest for validation scenarios
- Well-organized test fixtures following project conventions

**Requirements Traceability:**
All 6 acceptance criteria fully satisfied with corresponding test coverage:
- AC1: SkillManifest struct with required fields → `test_from_yaml_str_valid_minimal_manifest_succeeds`
- AC2: Optional fields support → `test_from_yaml_str_valid_full_manifest_succeeds`, default value tests
- AC3: YAML parser functionality → `from_yaml_str()` and `from_yaml_file()` tests
- AC4: Invalid manifest rejection → `test_from_yaml_str_invalid_yaml_fails`
- AC5: Required field validation → `test_validate_empty_*` test suite
- AC6: Unit test coverage → 14 comprehensive tests, all passing

### Refactoring Performed

**No refactoring required.** The implementation is production-ready as-is.

**Considered but not implemented:**
- Regex compilation optimization using `once_cell::Lazy` - Current implementation easily meets <5ms performance requirement, adding dependency not justified for micro-optimization that provides no measurable user benefit.

### Compliance Check

- Coding Standards: **✓** Perfect adherence
  - No `unwrap()`/`expect()` in application code
  - All public functions have comprehensive doc comments
  - Consistent use of `anyhow::Result<T>`
  - Proper import organization (std, external crates, internal modules)
  - All code passes `cargo clippy -- -D warnings`

- Project Structure: **✓** Compliant
  - Module created in `src/skills/` as specified in source tree
  - Test fixtures in `tests/fixtures/skills/` following conventions
  - Proper module exports via `pub use`

- Testing Strategy: **✓** Exceeds requirements
  - ≥80% coverage requirement met (comprehensive coverage achieved)
  - AAA pattern followed consistently
  - Test naming convention: `test_<function>_<scenario>_<expected_outcome>`
  - Parametric tests using rstest for validation scenarios
  - Co-located tests using `#[cfg(test)]`

- All ACs Met: **✓** Complete
  - All 6 acceptance criteria fully implemented and tested

### Improvements Checklist

**All items complete - no additional work required:**

- [x] Verify all tests pass (29 tests passing, 0 failed)
- [x] Verify clippy passes with -D warnings (clean)
- [x] Verify all acceptance criteria met (6/6 complete)
- [x] Verify comprehensive test coverage (14 manifest tests covering all scenarios)
- [x] Verify error handling uses anyhow::Result (consistent throughout)
- [x] Verify doc comments on all public APIs (complete and thorough)
- [x] Verify no unwrap/expect in application code (clean)
- [x] Verify serde attributes correct (proper use of rename_all, default, etc.)

### Security Review

**Status: PASS**

No security concerns identified. This module:
- Handles YAML parsing with proper error handling
- Validates input data (id format, required fields)
- Does not expose sensitive information
- Does not perform privileged operations
- Uses safe Rust with proper error propagation

### Performance Considerations

**Status: PASS**

Performance requirements fully met:
- Target: <5ms per manifest file
- Actual: <1ms (all 14 tests complete in 0.01s total)
- Validation is lightweight (simple string checks + single regex match)
- No blocking I/O during parsing (file reads are acceptable and efficient)

**Minor optimization opportunity (non-critical):**
Regex compilation in `validate()` could use `once_cell::Lazy` to cache the compiled regex. Current implementation compiles on each call but:
1. Still meets <5ms requirement with significant margin
2. Validation called once per manifest load (not in hot path)
3. Regex compilation cost is negligible (~microseconds)
4. Adding dependency not justified for this micro-optimization

### Files Modified During Review

**None** - No code modifications were necessary. The implementation is production-ready.

### Gate Status

**Gate: PASS** → docs/qa/gates/1.3-skill-manifest-data-structures-parser.yml

**Quality Score: 100/100**

**Rationale:** Exemplary implementation with comprehensive test coverage, perfect standards compliance, and no blocking issues. All acceptance criteria fully met with thorough testing. Code demonstrates professional software engineering practices and is ready for production use.

### Recommended Status

**✓ Ready for Done**

This story is complete and ready to be marked as Done. The implementation is production-ready, all acceptance criteria are met, tests are comprehensive and passing, and code quality is exemplary. No additional work required.
